# 向量数据库选型与优化

## 一、向量数据库对比

### 1.1 主流向量数据库

| 数据库       | 类型            | 优势                     | 劣势                     | 适用场景         |
| ------------ | --------------- | ------------------------ | ------------------------ | ---------------- |
| **Pinecone** | 云服务          | 性能强、易用、托管       | 贵($70/月起)、数据在云上 | 生产环境、大规模 |
| **Milvus**   | 开源            | 功能全、性能好、社区活跃 | 部署复杂、资源占用高     | 大规模、自建     |
| **Weaviate** | 开源            | 功能丰富、支持多模态     | 学习曲线陡               | 复杂场景         |
| **Qdrant**   | 开源            | Rust 编写、性能好        | 生态较小                 | 性能敏感         |
| **ChromaDB** | 开源            | 轻量、易用、可嵌入       | 功能相对简单             | MVP、中小规模    |
| **pgvector** | PostgreSQL 插件 | 无需额外服务、SQL 查询   | 性能一般                 | 已有 PG、小规模  |
| **Faiss**    | 库              | Meta 出品、性能极强      | 只是库不是数据库         | 研究、原型       |

### 1.2 我们的选择：ChromaDB

**选择理由**:

```
1. 快速开发: 5分钟集成，无需复杂配置
2. 成本低: 开源免费，自部署
3. 性能够用: 百万级文档，P99 < 100ms
4. 易维护: 单进程，无需独立集群
5. 可迁移: 后期可无缝迁移到Pinecone/Milvus
```

**权衡**:

```
✅ 适合MVP和中小规模（<1000万向量）
❌ 不适合超大规模（>1亿向量）
❌ 不适合多租户隔离要求极高的场景
```

---

## 二、ChromaDB 深度使用

### 2.1 基础操作

```typescript
import { Chroma } from "langchain/vectorstores/chroma";
import { OpenAIEmbeddings } from "langchain/embeddings/openai";

// 1. 初始化
const embeddings = new OpenAIEmbeddings();

const vectorStore = new Chroma(embeddings, {
  collectionName: "medical_knowledge",
  url: "http://localhost:8000", // ChromaDB服务地址
  collectionMetadata: {
    "hnsw:space": "cosine", // 距离度量
    "hnsw:construction_ef": 200,
    "hnsw:M": 16,
  },
});

// 2. 添加文档
await vectorStore.addDocuments([
  {
    pageContent: "头痛可以服用对乙酰氨基酚",
    metadata: { source: "medical_guide.pdf", page: 42 },
  },
  {
    pageContent: "发烧超过38.5°C需要就医",
    metadata: { source: "medical_guide.pdf", page: 43 },
  },
]);

// 3. 相似度检索
const results = await vectorStore.similaritySearch("头痛怎么办", 5);

// 4. 带分数的检索
const resultsWithScore = await vectorStore.similaritySearchWithScore(
  "头痛怎么办",
  5
);
// [{ document, score: 0.85 }, ...]

// 5. 元数据过滤
const filtered = await vectorStore.similaritySearch("头痛怎么办", 5, {
  source: "medical_guide.pdf",
});

// 6. MMR检索（最大边际相关性，增加多样性）
const mmrResults = await vectorStore.maxMarginalRelevanceSearch("头痛怎么办", {
  k: 5,
  fetchK: 20, // 先检索20个，再选5个最多样的
  lambda: 0.5, // 相关性vs多样性权重
});
```

### 2.2 批量操作优化

```typescript
// ❌ 逐个添加（慢）
for (const doc of documents) {
  await vectorStore.addDocuments([doc]);
}

// ✅ 批量添加（快10倍）
const BATCH_SIZE = 100;
for (let i = 0; i < documents.length; i += BATCH_SIZE) {
  const batch = documents.slice(i, i + BATCH_SIZE);
  await vectorStore.addDocuments(batch);
  console.log(`已处理 ${i + batch.length}/${documents.length}`);
}
```

### 2.3 Collection 管理

```typescript
import { ChromaClient } from "chromadb";

const client = new ChromaClient({ path: "http://localhost:8000" });

// 列出所有collection
const collections = await client.listCollections();

// 获取collection信息
const collection = await client.getCollection({ name: "medical_knowledge" });
const count = await collection.count();
console.log(`文档数量: ${count}`);

// 删除collection
await client.deleteCollection({ name: "old_collection" });

// 创建collection（带配置）
await client.createCollection({
  name: "new_collection",
  metadata: {
    "hnsw:space": "cosine",
    "hnsw:construction_ef": 200,
    "hnsw:M": 16,
    "hnsw:search_ef": 100,
  },
});
```

---

## 三、性能优化

### 3.1 HNSW 参数调优

**核心参数**:

```typescript
{
  'hnsw:space': 'cosine',        // 距离度量: cosine, l2, ip
  'hnsw:construction_ef': 200,   // 构建时搜索范围（越大越准但越慢）
  'hnsw:M': 16,                  // 每层最大连接数（越大越准但占内存）
  'hnsw:search_ef': 100          // 查询时搜索范围（越大越准但越慢）
}
```

**调优策略**:

```
场景1: 追求速度
{
  'hnsw:construction_ef': 100,
  'hnsw:M': 8,
  'hnsw:search_ef': 50
}
→ 检索速度快，召回率略低（~85%）

场景2: 追求准确率
{
  'hnsw:construction_ef': 400,
  'hnsw:M': 32,
  'hnsw:search_ef': 200
}
→ 召回率高（~95%），但慢2-3倍

场景3: 平衡（我们的选择）
{
  'hnsw:construction_ef': 200,
  'hnsw:M': 16,
  'hnsw:search_ef': 100
}
→ 召回率90%，P99延迟100ms
```

**A/B 测试结果**:

| 配置 | 召回率 | P99 延迟 | 内存占用 |
| ---- | ------ | -------- | -------- |
| 低配 | 85%    | 50ms     | 2GB      |
| 中配 | 90%    | 100ms    | 4GB      |
| 高配 | 95%    | 250ms    | 8GB      |

### 3.2 距离度量选择

```typescript
// 1. Cosine相似度（推荐）
'hnsw:space': 'cosine'
// 范围: [-1, 1]，1表示完全相同
// 优点: 不受向量长度影响，适合文本
// 公式: cos(θ) = (A·B) / (||A|| * ||B||)

// 2. 欧氏距离（L2）
'hnsw:space': 'l2'
// 范围: [0, ∞)，0表示完全相同
// 优点: 直观，适合图像
// 公式: √(Σ(Ai - Bi)²)

// 3. 内积（IP）
'hnsw:space': 'ip'
// 范围: (-∞, ∞)，越大越相似
// 优点: 速度快，适合已归一化的向量
// 公式: Σ(Ai * Bi)
```

**我们的选择**: Cosine

- 文本 Embedding 通常未归一化
- 不受文档长度影响
- 业界标准

### 3.3 索引优化

```typescript
// 1. 预热索引（首次查询会慢）
async function warmupIndex() {
  const dummyQueries = ["头痛", "发烧", "咳嗽", "腹痛", "失眠"];

  for (const query of dummyQueries) {
    await vectorStore.similaritySearch(query, 1);
  }

  console.log("索引预热完成");
}

// 2. 定期重建索引（优化碎片）
async function rebuildIndex() {
  // 导出数据
  const docs = await collection.get();

  // 删除旧collection
  await client.deleteCollection({ name: "medical_knowledge" });

  // 重建
  await client.createCollection({ name: "medical_knowledge" });
  await vectorStore.addDocuments(docs);

  console.log("索引重建完成");
}

// 每周执行一次
cron.schedule("0 2 * * 0", rebuildIndex);
```

### 3.4 缓存策略

```typescript
import { Redis } from "ioredis";
import { createHash } from "crypto";

class CachedVectorStore {
  private redis: Redis;
  private vectorStore: Chroma;

  constructor(vectorStore: Chroma) {
    this.redis = new Redis();
    this.vectorStore = vectorStore;
  }

  async similaritySearch(query: string, k: number) {
    // 1. 生成缓存key
    const cacheKey = this.getCacheKey(query, k);

    // 2. 尝试从缓存读取
    const cached = await this.redis.get(cacheKey);
    if (cached) {
      console.log("缓存命中");
      return JSON.parse(cached);
    }

    // 3. 缓存未命中，查询向量数据库
    const results = await this.vectorStore.similaritySearch(query, k);

    // 4. 写入缓存（1小时过期）
    await this.redis.set(cacheKey, JSON.stringify(results), "EX", 3600);

    return results;
  }

  private getCacheKey(query: string, k: number): string {
    const hash = createHash("md5").update(query).digest("hex");
    return `vector:search:${hash}:${k}`;
  }

  // 清除缓存（文档更新时调用）
  async invalidateCache() {
    const keys = await this.redis.keys("vector:search:*");
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}

// 使用
const cachedStore = new CachedVectorStore(vectorStore);
const results = await cachedStore.similaritySearch("头痛", 5);
```

**缓存效果**:

- 命中率: 40%
- 命中时延迟: 5ms（vs 100ms）
- 整体 P99 延迟: 从 100ms 降到 60ms

---

## 四、生产环境部署

### 4.1 Docker 部署

```yaml
# docker-compose.yml
version: "3.8"

services:
  chromadb:
    image: chromadb/chroma:latest
    ports:
      - "8000:8000"
    volumes:
      - ./chroma_data:/chroma/chroma
    environment:
      - CHROMA_SERVER_AUTH_CREDENTIALS=admin:password
      - CHROMA_SERVER_AUTH_PROVIDER=basic
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 8G
          cpus: "4"
```

```bash
# 启动
docker-compose up -d

# 查看日志
docker-compose logs -f chromadb

# 备份数据
tar -czf chroma_backup_$(date +%Y%m%d).tar.gz chroma_data/
```

### 4.2 监控指标

```typescript
import { Registry, Histogram, Counter, Gauge } from "prom-client";

const register = new Registry();

// 1. 检索延迟
const searchLatency = new Histogram({
  name: "vector_search_latency_ms",
  help: "向量检索延迟",
  labelNames: ["collection"],
  buckets: [10, 50, 100, 200, 500, 1000],
});

// 2. 检索QPS
const searchQPS = new Counter({
  name: "vector_search_total",
  help: "向量检索总数",
  labelNames: ["collection", "status"],
});

// 3. 文档数量
const documentCount = new Gauge({
  name: "vector_documents_total",
  help: "向量文档总数",
  labelNames: ["collection"],
});

// 4. 缓存命中率
const cacheHitRate = new Counter({
  name: "vector_cache_hits_total",
  help: "缓存命中次数",
  labelNames: ["hit"],
});

register.registerMetric(searchLatency);
register.registerMetric(searchQPS);
register.registerMetric(documentCount);
register.registerMetric(cacheHitRate);

// 使用
async function monitoredSearch(query: string, k: number) {
  const start = Date.now();

  try {
    const results = await vectorStore.similaritySearch(query, k);

    const latency = Date.now() - start;
    searchLatency.observe({ collection: "medical" }, latency);
    searchQPS.inc({ collection: "medical", status: "success" });

    return results;
  } catch (error) {
    searchQPS.inc({ collection: "medical", status: "error" });
    throw error;
  }
}

// 定期更新文档数量
setInterval(async () => {
  const count = await collection.count();
  documentCount.set({ collection: "medical" }, count);
}, 60000);

// Prometheus endpoint
app.get("/metrics", async (req, res) => {
  res.set("Content-Type", register.contentType);
  res.end(await register.metrics());
});
```

### 4.3 备份与恢复

```typescript
// 备份
async function backupCollection(collectionName: string) {
  const collection = await client.getCollection({ name: collectionName });

  // 获取所有数据
  const data = await collection.get({
    include: ["embeddings", "documents", "metadatas"],
  });

  // 保存到文件
  const backup = {
    collectionName,
    timestamp: new Date().toISOString(),
    count: data.ids.length,
    data,
  };

  await fs.writeFile(
    `backup_${collectionName}_${Date.now()}.json`,
    JSON.stringify(backup, null, 2)
  );

  console.log(`备份完成: ${data.ids.length} 条文档`);
}

// 恢复
async function restoreCollection(backupFile: string) {
  const backup = JSON.parse(await fs.readFile(backupFile, "utf-8"));

  // 创建collection
  await client.createCollection({ name: backup.collectionName });
  const collection = await client.getCollection({
    name: backup.collectionName,
  });

  // 批量添加
  const BATCH_SIZE = 1000;
  for (let i = 0; i < backup.data.ids.length; i += BATCH_SIZE) {
    await collection.add({
      ids: backup.data.ids.slice(i, i + BATCH_SIZE),
      embeddings: backup.data.embeddings.slice(i, i + BATCH_SIZE),
      documents: backup.data.documents.slice(i, i + BATCH_SIZE),
      metadatas: backup.data.metadatas.slice(i, i + BATCH_SIZE),
    });

    console.log(
      `已恢复 ${Math.min(i + BATCH_SIZE, backup.data.ids.length)}/${
        backup.data.ids.length
      }`
    );
  }

  console.log("恢复完成");
}

// 定时备份（每天凌晨2点）
cron.schedule("0 2 * * *", () => {
  backupCollection("medical_knowledge");
});
```

---

## 五、迁移方案

### 5.1 迁移到 Pinecone

```typescript
// 1. 从ChromaDB导出
const chromaData = await chromaCollection.get({
  include: ["embeddings", "documents", "metadatas"],
});

// 2. 导入到Pinecone
import { PineconeClient } from "@pinecone-database/pinecone";

const pinecone = new PineconeClient();
await pinecone.init({
  apiKey: process.env.PINECONE_API_KEY,
  environment: "us-west1-gcp",
});

const index = pinecone.Index("medical-knowledge");

// 3. 批量upsert
const BATCH_SIZE = 100;
for (let i = 0; i < chromaData.ids.length; i += BATCH_SIZE) {
  const batch = chromaData.ids.slice(i, i + BATCH_SIZE).map((id, idx) => ({
    id,
    values: chromaData.embeddings[i + idx],
    metadata: {
      text: chromaData.documents[i + idx],
      ...chromaData.metadatas[i + idx],
    },
  }));

  await index.upsert({ vectors: batch });
}
```

### 5.2 迁移到 Milvus

```typescript
import { MilvusClient } from "@zilliz/milvus2-sdk-node";

const milvus = new MilvusClient({
  address: "localhost:19530",
});

// 1. 创建collection
await milvus.createCollection({
  collection_name: "medical_knowledge",
  fields: [
    {
      name: "id",
      data_type: DataType.VarChar,
      max_length: 100,
      is_primary_key: true,
    },
    { name: "embedding", data_type: DataType.FloatVector, dim: 1536 },
    { name: "text", data_type: DataType.VarChar, max_length: 65535 },
  ],
});

// 2. 创建索引
await milvus.createIndex({
  collection_name: "medical_knowledge",
  field_name: "embedding",
  index_type: "HNSW",
  metric_type: "COSINE",
  params: { M: 16, efConstruction: 200 },
});

// 3. 导入数据
await milvus.insert({
  collection_name: "medical_knowledge",
  data: chromaData.ids.map((id, i) => ({
    id,
    embedding: chromaData.embeddings[i],
    text: chromaData.documents[i],
  })),
});
```

---

## 六、面试高频问题

**Q: 为什么选择 ChromaDB 而不是 Pinecone？**

A: "我们做了详细的技术选型:

**Pinecone 优势**:

- 性能更好（P99 < 50ms）
- 托管服务，运维简单
- 支持更大规模（亿级向量）

**ChromaDB 优势**:

- 成本低（Pinecone $70/月起，我们自部署免费）
- 数据自主可控
- 开发速度快，5 分钟集成

**我们的决策**:

- MVP 阶段用 ChromaDB 快速验证
- 数据量<100 万，ChromaDB 性能够用（P99 100ms）
- 预留迁移方案，后期可无缝切换到 Pinecone

**结果**: 节省成本$840/年，性能满足需求，3 个月后根据业务增长再评估是否迁移。"

**Q: 如何优化向量检索性能？**

A: "我们用了四个策略:

1. **HNSW 参数调优**:

   - 测试了不同 M 和 ef 值，最终选择 M=16, ef=100
   - 召回率 90%，P99 延迟 100ms

2. **Redis 缓存**:

   - 缓存热门查询结果
   - 命中率 40%，命中时延迟 5ms

3. **批量操作**:

   - 批量添加文档，速度提升 10 倍
   - 批量检索，减少网络开销

4. **索引预热**:
   - 服务启动时预热索引
   - 避免首次查询慢的问题

**效果**: P99 延迟从 250ms 降到 100ms，再加上缓存降到 60ms。"

**Q: 向量数据库和传统数据库有什么区别？**

A: "核心区别是查询方式:

**传统数据库**:

- 精确匹配: WHERE name = '张三'
- 基于索引: B-Tree, Hash
- 时间复杂度: O(log N)

**向量数据库**:

- 相似度匹配: 找最相似的 K 个向量
- 基于 ANN 算法: HNSW, IVF
- 时间复杂度: O(log N) 但常数更大

**适用场景**:

- 传统 DB: 结构化数据、精确查询
- 向量 DB: 非结构化数据、语义搜索

**我们的实践**: 两者结合使用

- PostgreSQL 存储结构化数据（用户、订单）
- ChromaDB 存储向量（医疗知识）
- 通过 ID 关联"
