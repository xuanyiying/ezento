/* eslint-disable prettier/prettier */
/**
 * Model Admin Controller
 * Provides API endpoints for managing AI model configurations
 */

import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  HttpCode,
  HttpStatus,
  Logger,
  Query,
  BadRequestException,
} from '@nestjs/common';
import { ModelConfigService, ModelConfig } from './config/model-config.service';
import { AIProviderFactory } from './factory/ai-provider.factory';

/**
 * DTO for creating/updating model configurations
 */
export class UpsertModelConfigDto {
  name: string;
  provider: string;
  apiKey: string;
  endpoint?: string;
  defaultTemperature?: number;
  defaultMaxTokens?: number;
  costPerInputToken?: number;
  costPerOutputToken?: number;
  rateLimitPerMinute?: number;
  rateLimitPerDay?: number;
  isActive?: boolean;
}

/**
 * Model Admin Controller
 * Manages AI model configurations dynamically
 */
@Controller('/admin/models')
export class ModelAdminController {
  private readonly logger = new Logger(ModelAdminController.name);

  constructor(
    private readonly modelConfigService: ModelConfigService,
    private readonly providerFactory: AIProviderFactory
  ) {}

  /**
   * Get all model configurations
   */
  @Get()
  async listModels(
    @Query('provider') provider?: string,
    @Query('isActive') isActive?: string,
    @Query('page') page: string = '1',
    @Query('limit') limit: string = '50'
  ) {
    let configs = await this.modelConfigService.getAllModelConfigs();

    if (provider) {
      configs = await this.modelConfigService.getConfigsByProvider(provider);
    }

    if (isActive !== undefined) {
      const activeFilter = isActive === 'true';
      configs = configs.filter((c) => c.isActive === activeFilter);
    }

    // Pagination
    const pageNum = parseInt(page, 10);
    const limitNum = parseInt(limit, 10);
    const start = (pageNum - 1) * limitNum;
    const end = start + limitNum;

    // Mask API keys in response
    const maskedConfigs = configs.map((config) => ({
      ...config,
      apiKey: this.maskApiKey(config.apiKey),
    }));

    return {
      data: maskedConfigs.slice(start, end),
      total: configs.length,
      page: pageNum,
      limit: limitNum,
      totalPages: Math.ceil(configs.length / limitNum),
    };
  }

  /**
   * Get model configuration by name
   */
  @Get(':name')
  async getConfig(@Param('name') name: string): Promise<ModelConfig | null> {
    return this.modelConfigService.getModelConfig(name);
  }

  /**
   * Get configurations by provider
   */
  @Get('provider/:provider')
  async getConfigsByProvider(
    @Param('provider') provider: string
  ): Promise<ModelConfig[]> {
    return this.modelConfigService.getConfigsByProvider(provider);
  }

  /**
   * Create or update model configuration
   */
  @Post()
  async upsertConfig(@Body() dto: UpsertModelConfigDto): Promise<ModelConfig> {
    const config: ModelConfig = {
      id: '', // Will be generated by database
      name: dto.name,
      provider: dto.provider,
      apiKey: dto.apiKey,
      endpoint: dto.endpoint,
      defaultTemperature: dto.defaultTemperature ?? 0.7,
      defaultMaxTokens: dto.defaultMaxTokens ?? 2000,
      costPerInputToken: dto.costPerInputToken ?? 0,
      costPerOutputToken: dto.costPerOutputToken ?? 0,
      rateLimitPerMinute: dto.rateLimitPerMinute ?? 0,
      rateLimitPerDay: dto.rateLimitPerDay ?? 0,
      isActive: dto.isActive ?? true,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const result = await this.modelConfigService.upsertModelConfig(config);

    // Reload providers to apply new configuration
    await this.providerFactory.reloadProviders();

    this.logger.log(`Model configuration upserted: ${dto.name}`);
    return result;
  }

  /**
   * Update model configuration
   */
  @Put(':name')
  async updateConfig(
    @Param('name') name: string,
    @Body() dto: Partial<UpsertModelConfigDto>
  ): Promise<ModelConfig> {
    const existing = await this.modelConfigService.getModelConfig(name);
    if (!existing) {
      throw new BadRequestException(`Model ${name} not found`);
    }

    const config: ModelConfig = {
      ...existing,
      ...dto,
      updatedAt: new Date(),
    } as ModelConfig;

    const result = await this.modelConfigService.upsertModelConfig(config);
    await this.providerFactory.reloadProviders();
    this.logger.log(`Model configuration updated: ${name}`);
    return result;
  }

  /**
   * Enable model configuration
   */
  @Post(':name/enable')
  @HttpCode(HttpStatus.NO_CONTENT)
  async enableConfig(@Param('name') name: string): Promise<void> {
    await this.modelConfigService.enableModelConfig(name);
    await this.providerFactory.reloadProviders();
    this.logger.log(`Model configuration enabled: ${name}`);
  }

  /**
   * Disable model configuration
   */
  @Post(':name/disable')
  @HttpCode(HttpStatus.NO_CONTENT)
  async disableConfig(@Param('name') name: string): Promise<void> {
    await this.modelConfigService.disableModelConfig(name);
    await this.providerFactory.reloadProviders();
    this.logger.log(`Model configuration disabled: ${name}`);
  }

  /**
   * Delete model configuration
   */
  @Delete(':name')
  @HttpCode(HttpStatus.NO_CONTENT)
  async deleteConfig(@Param('name') name: string): Promise<void> {
    await this.modelConfigService.deleteModelConfig(name);
    await this.providerFactory.reloadProviders();
    this.logger.log(`Model configuration deleted: ${name}`);
  }

  /**
   * Refresh configuration cache
   */
  @Post('refresh')
  @HttpCode(HttpStatus.NO_CONTENT)
  async refreshCache(): Promise<void> {
    await this.modelConfigService.refreshCache();
    await this.providerFactory.reloadProviders();
    this.logger.log('Configuration cache refreshed');
  }

  /**
   * Get provider statuses
   */
  @Get('status/all')
  async getAllProviderStatuses() {
    return this.providerFactory.getAllProviderStatuses();
  }

  /**
   * Get specific provider status
   */
  @Get('status/:provider')
  async getProviderStatus(@Param('provider') provider: string) {
    return this.providerFactory.getProviderStatus(provider);
  }

  /**
   * Trigger health check for a model
   */
  @Post(':name/test')
  async testModel(@Param('name') name: string) {
    const config = await this.modelConfigService.getModelConfig(name);
    if (!config) {
      throw new BadRequestException(`Model ${name} not found`);
    }
    const isHealthy = await this.providerFactory.checkProviderHealth(
      config.provider
    );
    return {
      name,
      provider: config.provider,
      status: isHealthy ? 'valid' : 'error',
      message: isHealthy ? 'Connection successful' : 'Connection failed',
    };
  }

  /**
   * Trigger health check for a provider
   */
  @Post('health-check/:provider')
  async checkProviderHealth(@Param('provider') provider: string) {
    const isHealthy = await this.providerFactory.checkProviderHealth(provider);
    return { provider, isHealthy };
  }

  /**
   * Mask API key for security
   */
  private maskApiKey(apiKey: string): string {
    if (!apiKey || apiKey.length < 8) {
      return '****';
    }
    return `${apiKey.slice(0, 4)}${'*'.repeat(apiKey.length - 8)}${apiKey.slice(-4)}`;
  }
}
